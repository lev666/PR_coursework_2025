# PR_coursework_2025
[![MIT License](https://img.shields.io/badge/License-MIT-green.svg)](https://github.com/lev666/PR_coursework_2025/blob/main/LICENSE)
***Term paper for the fall semester, 1st year, in the subject Programming***

# Task option 4.8 (technical specifications)

* Вывод программы должен быть произведен в стандартный поток вывода: stdout.

* Ввод данных в программе в стандартный поток ввода: stdin.

* В случае использования Makefile название исполняемого файла должно быть: cw.

* Важно: первой строкой при запуске программы нужно выводить информацию о варианте курсовой работе и об авторе программы в строго определенном формате:
Course work for option <V>, created by <Name> <Surname>.
Где V – вариант курсовой и Имя и Фамилия, как указано в репозитории группы. Данное предложение должно быть строго первым предложением в выводе программы и является отдельной строкой (заканчивается знаком ‘\n’).
Например:
	Course work for option 3.2, created by Ivan Ivanov.


## Ввод данных: {#funcnum}

* После вывода информацию о варианте курсовой работе программа ожидает ввода пользователем числа – номера команды:
```
0 – вывод текста после первичной обязательной обработки (если предусмотрена заданием данного уровня сложности)

1 – вызов функции под номером 1 из списка задания

2 – вызов функции под номером 2 из списка задания

3 – вызов функции под номером 3 из списка задания

4 – вызов функции под номером 4 из списка задания

5 – вывод справки о функциях, которые реализует программа.
```

Программа не должна выводить никаких строк, пока пользователь не введет число.


* В случае вызова справки (опция 5) текст на вход подаваться не должен, во всех остальных случаях после выбора опции должен быть считан текст.
Признаком конца текста считается два подряд идущих символа переноса строки ‘\n’. После каждой из функций нужно вывести результат работы программы и завершить программу.

* В случае ошибки и невозможности выполнить функцию по какой-либо причине, нужно вывести строку:
	Error: <причина ошибки>

* Каждое предложение должно выводиться в отдельной строке, пустых строк быть не должно. Текст представляет собой предложения, разделенные точкой. Предложения – набор слов. Слова состоят из латинских букв, цифр и символа '-'. Остальные символы являются разделителями между словами. Длина текста и каждого предложения заранее не известна.

* Программа должна сохранить этот текст в динамический массив строк и оперировать далее только с ним.

* Программа должна найти и удалить все повторно встречающиеся предложения (сравнивать их следует посимвольно, но без учета регистра).

* Программа должна выполнить одно из введенных пользователем действий и завершить работу:

* 1) Вывести все предложения в которых есть дата с текущим годом и месяцем. (дата записывается в формате DD/MM/YYYY)

* 2) Отсортировать предложения по увеличению минимальной даты в них. Если в предложении нет даты, то следует считать, что "мнимая минимальная дата" == ∞. В случае равенства сохранить порядок вхождения.

* 3) Удалить все предложения в которых все даты относятся к 19 веку.

* 4) Для каждого предложения вывести самую раннюю и позднюю дату. Предложения выводит не нужно. Если предложение не содержит дату, то его не нужно выводить. Для каждого предложения последовательно выводятся строки формата "Earliest date: <date>" и "Latest date: <date>". Если в предложении одна дата -- то она одновременно и ранняя и поздняя. Пример: исходное предложение "15/08/1722 UOEAkpDq 06/08/1832 oFtEgRt 05/10/1972." Выводятся 2 строки -- "Earliest date: 15/08/1722" и "Latest date: 05/10/1972".

* Все сортировки должны осуществляться с использованием функции стандартной библиотеки. Использование собственных функций, при наличии аналога среди функций стандартной библиотеки, запрещается.

* Все подзадачи, ввод/вывод должны быть реализованы в виде отдельной функции.

## Задание на защиту (Предварительная):

Добавьте в вашу курсовую работу функцию под номером '9', которая выполняет задание ниже:
На вход, после номер задания, подается строка (не более 100 символов) состоящаяя из трех слов:
filler-word sep1 sep2
Далее подается текст.
Необходимо склеить по словам два соседних предложения.
Если в одном предложении из пары предложений слов больше, чем в другом, то слова без пары склеиваются с filler-word.
Предложения и слова нумеруются с 0. Каждая четная пара склеивается с помощью sep1, каждая нечетная -- с помощью sep2.
Если предложений нечётное количество, то слова последнего предложения склеить с filler-word.
На первом месте в паре стоит слово из первого предложения в паре предложений (или филлер), на втором месте -- слово из второго предложения в паре предложений (или филлер).
После склееной пары должны идти разделители после слов пары в оригинальном тексте -- сначала разделитель, что после первого слова, затем разделитель, что после второго слова.
В случае использования filler-word считать, что после него нет разделителя.

## Упрощенное задание на защиту (предварительную) на оценку "удовлетворительно":

Добавьте в вашу курсовую работу функцию под номером '8', которая выполняет задание ниже:
Среди всех предложений найти такие, которые состоят из одинакового набора слов (по количеству и содержанию).
Гарантируется, что пар предложений, состоящих из одинакового набора слов (по количеству и содержанию), не более одной (для одного набора слов будет максимум одна пара предложений, но таких наборов может быть несколько).
Слова сравнивать без учета регистра.
Вывести такие пары предложений в формате
"<Первое предложение без точки> ::: <Второе предложение без точки>."
Выводить пары в порядке вхождения первого предложения.

## Сборка и Запуск

Проект использует `make` для управления сборкой, тестированием и очисткой.

### Основные команды (Цели)

* `make all` / `make`
    Собирает быструю "release" версию программы (`cw`).

* `make debug`
    Собирает отладочную версию (`cw.dbg`) с флагом `-g`.

* `make test`
    Запускает скрипт `run_tests.sh`, который проверяет бинарник `cw.dbg` на наборе тестовых данных.

* `make clean`
    Удаляет все сгенерированные файлы (`.o`, `.d`) из папки `build/` и итоговые бинарники.

* `make doxy`
    Генерация документации с помощью Doxygen.
    
* `make doxy_pdf`
    Генерация документации с помощью Doxygen в формате pdf.
    
## Генерация документации

Для корректной работы генерации документации через Doxygen требуется его установленная версия на локальном устройтсве.

## Дисклеймер

Данный проект является исключительно практикой в образовательных целях и [я](https://github.com/lev666) не несу никакой ответственности за ваши данные при использовании моего проекта